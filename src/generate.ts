// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: 2023-Present The Kubernetes Fluent Client Authors

import { loadAllYaml } from "@kubernetes/client-node";
import * as fs from "fs";
import * as path from "path";
import {
  FetchingJSONSchemaStore,
  InputData,
  JSONSchemaInput,
  TargetLanguage,
  quicktype,
} from "quicktype-core";

import { fetch } from "./fetch";
import { K8s } from "./fluent";
import { CustomResourceDefinition } from "./upstream";
import { LogFn } from "./types";

export interface GenerateOptions {
  /** The source URL, yaml file path or K8s CRD name */
  source: string;
  /** The output directory path */
  directory?: string;
  /** Disable kubernetes-fluent-client wrapping */
  plain?: boolean;
  /** The language to generate types in */
  language?: string | TargetLanguage;
  /** Override the NPM package to import when generating formatted Typescript */
  npmPackage?: string;
  /** Log function callback */
  logFn: LogFn;
}

/**
 * Converts a CustomResourceDefinition to TypeScript types
 *
 * @param crd The CustomResourceDefinition to convert
 * @param opts The options to use when converting
 * @returns A promise that resolves when the CustomResourceDefinition has been converted
 */
async function convertCRDtoTS(
  crd: CustomResourceDefinition,
  opts: GenerateOptions,
): Promise<Record<string, string[]>> {
  // Get the name of the kind
  const name = crd.spec.names.kind;

  const results: Record<string, string[]> = {};

  for (const match of crd.spec.versions) {
    const version = match.name;

    // Get the schema from the matched version
    const schema = JSON.stringify(match?.schema?.openAPIV3Schema);

    // Create a new JSONSchemaInput
    const schemaInput = new JSONSchemaInput(new FetchingJSONSchemaStore());

    opts.logFn(`- Generating ${crd.spec.group}/${version} types for ${name}`);

    // Add the schema to the input
    await schemaInput.addSource({ name, schema });

    // Create a new InputData object
    const inputData = new InputData();
    inputData.addInput(schemaInput);

    // If the language is not specified, default to TypeScript
    if (!opts.language) {
      opts.language = "ts";
    }

    // Generate the types
    const out = await quicktype({
      inputData,
      lang: opts.language,
      rendererOptions: { "just-types": "true" },
    });

    let processedLines = out.lines;

    // If using typescript, remove the line containing `[property: string]: any;`
    if (opts.language === "ts" || opts.language === "typescript") {
      processedLines = out.lines.filter(line => !line.includes("[property: string]: any;"));
    }

    // If the language is TypeScript and plain is not specified, wire up the fluent client
    if (opts.language === "ts" && !opts.plain) {
      if (!opts.npmPackage) {
        opts.npmPackage = "kubernetes-fluent-client";
      }

      processedLines.unshift(
        // Add warning that the file is auto-generated
        `// This file is auto-generated by ${opts.npmPackage}, do not edit manually\n`,
        // Add the imports before any other lines
        `import { GenericKind, RegisterKind } from "${opts.npmPackage}";\n`,
      );

      // Replace the interface with a named class that extends GenericKind
      const entryIdx = processedLines.findIndex(line =>
        line.includes(`export interface ${name} {`),
      );

      // Replace the interface with a named class that extends GenericKind
      processedLines[entryIdx] = `export class ${name} extends GenericKind {`;

      // Add the RegisterKind call
      processedLines.push(`RegisterKind(${name}, {`);
      processedLines.push(`  group: "${crd.spec.group}",`);
      processedLines.push(`  version: "${version}",`);
      processedLines.push(`  kind: "${name}",`);
      processedLines.push(`});`);
    }

    const finalContents = processedLines.join("\n");
    const fileName = `${name.toLowerCase()}-${version.toLowerCase()}`;

    // If an output file is specified, write the output to the file
    if (opts.directory) {
      // Create the directory if it doesn't exist
      fs.mkdirSync(opts.directory, { recursive: true });

      // Write the file
      const filePath = path.join(opts.directory, `${fileName}.${opts.language}`);
      fs.writeFileSync(filePath, finalContents);
    }

    // Add the results to the array
    results[fileName] = processedLines;
  }

  return results;
}

/**
 * Reads a CustomResourceDefinition from a file, the cluster or the internet
 *
 * @param opts The options to use when reading
 * @returns A promise that resolves when the CustomResourceDefinition has been read
 */
async function readOrFetchCrd(opts: GenerateOptions): Promise<CustomResourceDefinition[]> {
  const { source, logFn } = opts;
  let filePath: string;

  if (source[0] === "/") {
    // If source is an absolute path
    filePath = source;
  } else {
    // If source is a relative path
    filePath = path.join(process.cwd(), source);
  }

  // First try to read the source as a file
  try {
    if (fs.existsSync(filePath)) {
      logFn(`Attempting to load ${source} as a local file`);
      const payload = fs.readFileSync(filePath, "utf8");
      return loadAllYaml(payload) as CustomResourceDefinition[];
    }
  } catch (e) {
    // Ignore errors
  }

  // Next try to parse the source as a URL
  try {
    const url = new URL(source);

    // If the source is a URL, fetch it
    if (url.protocol === "http:" || url.protocol === "https:") {
      logFn(`Attempting to load ${source} as a URL`);
      const { ok, data } = await fetch<string>(source);

      // If the request failed, throw an error
      if (!ok) {
        throw new Error(`Failed to fetch ${source}: ${data}`);
      }

      return loadAllYaml(data) as CustomResourceDefinition[];
    }
  } catch (e) {
    // If invalid, ignore the error
    if (e.code !== "ERR_INVALID_URL") {
      throw new Error(e);
    }
  }

  // Finally, if the source is not a file or URL, try to read it as a CustomResourceDefinition from the cluster
  try {
    logFn(`Attempting to read ${source} from the current Kubernetes context`);
    return [await K8s(CustomResourceDefinition).Get(source)];
  } catch (e) {
    throw new Error(
      `Failed to read ${source} as a file, url or K8s CRD: ${
        e.data?.message || "Cluster not available"
      }`,
    );
  }
}

/**
 * Generate TypeScript types from a K8s CRD
 *
 * @param opts The options to use when generating
 * @returns A promise that resolves when the TypeScript types have been generated
 */
export async function generate(opts: GenerateOptions) {
  const crds = (await readOrFetchCrd(opts)).filter(crd => !!crd);
  const results: Record<string, string[]> = {};

  opts.logFn("");

  for (const crd of crds) {
    if (crd.kind !== "CustomResourceDefinition" || !crd.spec?.versions?.length) {
      opts.logFn(`Skipping ${crd?.metadata?.name}, it does not appear to be a CRD`);
      // Ignore empty and non-CRD objects
      continue;
    }

    // Add the results to the record
    const out = await convertCRDtoTS(crd, opts);
    for (const key of Object.keys(out)) {
      results[key] = out[key];
    }
  }

  if (opts.directory) {
    // Notify the user that the files have been generated
    opts.logFn(
      `\nâœ… Generated ${Object.keys(results).length} files in the ${opts.directory} directory`,
    );
  }

  return results;
}
