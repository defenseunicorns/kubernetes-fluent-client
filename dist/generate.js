"use strict";
// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: 2023-Present The Kubernetes Fluent Client Authors
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generate = void 0;
const client_node_1 = require("@kubernetes/client-node");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const quicktype_core_1 = require("quicktype-core");
const fetch_1 = require("./fetch");
const fluent_1 = require("./fluent");
const upstream_1 = require("./upstream");
/**
 * Converts a CustomResourceDefinition to TypeScript types
 *
 * @param crd The CustomResourceDefinition to convert
 * @param opts The options to use when converting
 * @returns A promise that resolves when the CustomResourceDefinition has been converted
 */
async function convertCRDtoTS(crd, opts) {
    // Get the name of the kind
    const name = crd.spec.names.kind;
    const results = {};
    for (const match of crd.spec.versions) {
        const version = match.name;
        // Get the schema from the matched version
        const schema = JSON.stringify(match?.schema?.openAPIV3Schema);
        // Create a new JSONSchemaInput
        const schemaInput = new quicktype_core_1.JSONSchemaInput(new quicktype_core_1.FetchingJSONSchemaStore());
        opts.logFn(`- Generating ${crd.spec.group}/${version} types for ${name}`);
        // Add the schema to the input
        await schemaInput.addSource({ name, schema });
        // Create a new InputData object
        const inputData = new quicktype_core_1.InputData();
        inputData.addInput(schemaInput);
        // If the language is not specified, default to TypeScript
        if (!opts.language) {
            opts.language = "ts";
        }
        // Generate the types
        const out = await (0, quicktype_core_1.quicktype)({
            inputData,
            lang: opts.language,
            rendererOptions: { "just-types": "true" },
        });
        let processedLines = out.lines;
        // If using typescript, remove the line containing `[property: string]: any;`
        if (opts.language === "ts" || opts.language === "typescript") {
            processedLines = out.lines.filter(line => !line.includes("[property: string]: any;"));
        }
        // If the language is TypeScript and plain is not specified, wire up the fluent client
        if (opts.language === "ts" && !opts.plain) {
            if (!opts.npmPackage) {
                opts.npmPackage = "kubernetes-fluent-client";
            }
            processedLines.unshift(
            // Add warning that the file is auto-generated
            `// This file is auto-generated by ${opts.npmPackage}, do not edit manually\n`, 
            // Add the imports before any other lines
            `import { GenericKind, RegisterKind } from "${opts.npmPackage}";\n`);
            // Replace the interface with a named class that extends GenericKind
            const entryIdx = processedLines.findIndex(line => line.includes(`export interface ${name} {`));
            // Replace the interface with a named class that extends GenericKind
            processedLines[entryIdx] = `export class ${name} extends GenericKind {`;
            // Add the RegisterKind call
            processedLines.push(`RegisterKind(${name}, {`);
            processedLines.push(`  group: "${crd.spec.group}",`);
            processedLines.push(`  version: "${version}",`);
            processedLines.push(`  kind: "${name}",`);
            processedLines.push(`  plural: "${crd.spec.names.plural}",`);
            processedLines.push(`});`);
        }
        const finalContents = processedLines.join("\n");
        const fileName = `${name.toLowerCase()}-${version.toLowerCase()}`;
        // If an output file is specified, write the output to the file
        if (opts.directory) {
            // Create the directory if it doesn't exist
            fs.mkdirSync(opts.directory, { recursive: true });
            // Write the file
            const filePath = path.join(opts.directory, `${fileName}.${opts.language}`);
            fs.writeFileSync(filePath, finalContents);
        }
        // Add the results to the array
        results[fileName] = processedLines;
    }
    return results;
}
/**
 * Reads a CustomResourceDefinition from a file, the cluster or the internet
 *
 * @param opts The options to use when reading
 * @returns A promise that resolves when the CustomResourceDefinition has been read
 */
async function readOrFetchCrd(opts) {
    const { source, logFn } = opts;
    let filePath;
    if (source[0] === "/") {
        // If source is an absolute path
        filePath = source;
    }
    else {
        // If source is a relative path
        filePath = path.join(process.cwd(), source);
    }
    // First try to read the source as a file
    try {
        if (fs.existsSync(filePath)) {
            logFn(`Attempting to load ${source} as a local file`);
            const payload = fs.readFileSync(filePath, "utf8");
            return (0, client_node_1.loadAllYaml)(payload);
        }
    }
    catch (e) {
        // Ignore errors
    }
    // Next try to parse the source as a URL
    try {
        const url = new URL(source);
        // If the source is a URL, fetch it
        if (url.protocol === "http:" || url.protocol === "https:") {
            logFn(`Attempting to load ${source} as a URL`);
            const { ok, data } = await (0, fetch_1.fetch)(source);
            // If the request failed, throw an error
            if (!ok) {
                throw new Error(`Failed to fetch ${source}: ${data}`);
            }
            return (0, client_node_1.loadAllYaml)(data);
        }
    }
    catch (e) {
        // If invalid, ignore the error
        if (e.code !== "ERR_INVALID_URL") {
            throw new Error(`Error parsing URL ${source}`);
        }
    }
    // Finally, if the source is not a file or URL, try to read it as a CustomResourceDefinition from the cluster
    try {
        logFn(`Attempting to read ${source} from the current Kubernetes context`);
        return [await (0, fluent_1.K8s)(upstream_1.CustomResourceDefinition).Get(source)];
    }
    catch (e) {
        throw new Error(`Failed to read ${source} as a file, url or K8s CRD: ${e.data?.message || "Cluster not available"}`);
    }
}
/**
 * Generate TypeScript types from a K8s CRD
 *
 * @param opts The options to use when generating
 * @returns A promise that resolves when the TypeScript types have been generated
 */
async function generate(opts) {
    const crds = (await readOrFetchCrd(opts)).filter(crd => !!crd);
    const results = {};
    opts.logFn("");
    for (const crd of crds) {
        if (crd.kind !== "CustomResourceDefinition" || !crd.spec?.versions?.length) {
            opts.logFn(`Skipping ${crd?.metadata?.name}, it does not appear to be a CRD`);
            // Ignore empty and non-CRD objects
            continue;
        }
        // Add the results to the record
        const out = await convertCRDtoTS(crd, opts);
        for (const key of Object.keys(out)) {
            results[key] = out[key];
        }
    }
    if (opts.directory) {
        // Notify the user that the files have been generated
        opts.logFn(`\nâœ… Generated ${Object.keys(results).length} files in the ${opts.directory} directory`);
    }
    return results;
}
exports.generate = generate;
